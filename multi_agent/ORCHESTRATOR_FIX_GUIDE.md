# Orchestrator Fix: Resolving the Iterative Loop Bug

## 1. Overview

This document outlines the necessary code changes to fix a critical bug in the `Orchestrator` where it fails to execute "fix" tasks generated by the `iterative_loop`, causing it to get stuck in a repetitive loop without making progress.

The problem is that the main execution loop does not update the workflow's `TodoList` after the iterative process runs. When the `iterative_loop` detects a failure and creates new fix tasks, the `Orchestrator` is unaware of them and attempts to re-run the original, failed task in the next iteration.

## 2. The Fix: Updating the TodoList

The solution is to make the `Orchestrator` aware of the changes made by the `iterative_loop`. After the loop runs, we will check if it produced a new, updated `TodoList` (containing fix tasks). If it did, we will replace the workflow's old `TodoList` with the new one.

## 3. Implementation Steps

You will need to modify the `run` method within `multi_agent/cli.py`.

### File to Edit: `multi_agent/cli.py`

Locate the `run` method inside the `OrchestratorCLI` class. You will add a few lines of code after the `self.iterative_loop.run(workflow)` call to handle the updated `TodoList`.

```python
// ... existing code in multi_agent/cli.py ...
            elif command.startswith("iterate"):
                parts = command.split()
                if len(parts) > 1:
                    workflow_id = parts[1]
                    if workflow_id in self.orchestrator.workflows:
                        workflow = self.orchestrator.workflows[workflow_id]
                        
                        # This is the main call to the iterative loop
                        results = self.iterative_loop.run(workflow)
                        
                        # --- BEGIN FIX ---
                        # After the loop, check if a new TodoList was generated
                        # and update the orchestrator's state.
                        if results and results.get("updated_todo_list"):
                            new_todo_list = results["updated_todo_list"]
                            
                            # Update the orchestrator's internal todolist
                            self.orchestrator.todo_lists[workflow.todo_list_id] = new_todo_list
                            
                            # Reload the workflow tasks to reflect the new "fix" tasks
                            self.orchestrator.reload_workflow_tasks(workflow_id)
                            
                            console.print(f"[bold green]âœ“ Orchestrator updated with {len(new_todo_list.get('items', [])) - len(workflow.tasks)} new fix task(s).[/bold green]")
                        # --- END FIX ---

                    else:
                        console.print(f"[bold red]Error: Workflow '{workflow_id}' not found.[/bold red]")
// ... existing code ...
```

### Add a New Method to `multi_agent/orchestrator_service/orchestrator.py`

To support the fix above, you need to add the `reload_workflow_tasks` method to your `MinimalOrchestrator` class. This method will clear the old tasks and load the new ones from the updated `TodoList`.

#### File to Edit: `multi_agent/orchestrator_service/orchestrator.py`

```python
// ... existing code in multi_agent/orchestrator_service/orchestrator.py ...

class MinimalOrchestrator:
    """
    Minimal orchestrator for executing todo lists.
    ...
    """
    
    def __init__(self, use_message_bus: bool = False):
// ... existing code ...
        
        logger.info("Initialized MinimalOrchestrator")
    
    # --- BEGIN NEW METHOD ---
    def reload_workflow_tasks(self, workflow_id: str):
        """
        Reloads the tasks for a workflow from its updated todo list.
        This is used after the iterative loop adds new 'fix' tasks.
        """
        if workflow_id not in self.workflows:
            raise ValueError(f"Workflow not found: {workflow_id}")

        workflow = self.workflows[workflow_id]
        todo_list_id = workflow.todo_list_id

        if todo_list_id not in self.todo_lists:
            raise ValueError(f"Todo list not found for workflow: {todo_list_id}")

        todo_list = self.todo_lists[todo_list_id]
        
        # Create a new task state dictionary
        new_tasks = {}
        for item in todo_list.get('items', []):
            task_id = item['id']
            # If the task already existed, keep its state, otherwise create a new one
            if task_id in workflow.tasks:
                # Preserve completed states, reset others to pending
                if workflow.tasks[task_id].status == TaskStatus.COMPLETED:
                    new_tasks[task_id] = workflow.tasks[task_id]
                else:
                     new_tasks[task_id] = TaskState(task_id=task_id, status=TaskStatus.PENDING)
            else:
                # This is a new "fix" task
                new_tasks[task_id] = TaskState(task_id=task_id, status=TaskStatus.PENDING)

        workflow.tasks = new_tasks
        logger.info(f"Reloaded and updated tasks for workflow {workflow_id}. Now has {len(workflow.tasks)} tasks.")
    # --- END NEW METHOD ---

    def _setup_subscriptions(self):
// ... existing code ...
```

## 4. Summary of Changes

1.  **`cli.py`**: After the `iterate` command runs, it now checks for an `updated_todo_list` in the results. If found, it updates the orchestrator's records and calls the new `reload_workflow_tasks` method.
2.  **`orchestrator_service/orchestrator.py`**: A new method, `reload_workflow_tasks`, is added to properly load the new set of tasks (including fixes) into the active workflow, ensuring the next iteration executes the correct "fix" task.

After applying these changes, the iterative loop will correctly execute the generated fix tasks instead of repeating the original failed task.
