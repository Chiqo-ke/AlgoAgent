from typing import Callable, Dict, List, Any

REGISTRY: Dict[str, dict] = {}

def register(name: str, callable: Callable, inputs: List[str], outputs: List[str], defaults: Dict[str, Any] = None, source_hint: str = "custom"):
    """
    Registers an indicator with the global registry.

    Args:
        name (str): The name of the indicator (case-insensitive).
        callable (Callable): The function that computes the indicator.
        inputs (List[str]): A list of required input column names (e.g., ['close']).
        outputs (List[str]): A list of output column names generated by the indicator.
        defaults (Dict[str, Any], optional): Default parameters for the indicator. Defaults to None.
        source_hint (str, optional): A hint about the source of the implementation (e.g., "talib", "ta", "custom"). Defaults to "custom".
    """
    REGISTRY[name.lower()] = {
        "callable": callable,
        "inputs": inputs,
        "outputs": outputs,
        "defaults": defaults or {},
        "source_hint": source_hint,
    }

def get_entry(name: str) -> Dict[str, Any]:
    """
    Retrieves an indicator entry from the registry.

    Args:
        name (str): The name of the indicator (case-insensitive).

    Returns:
        Dict[str, Any]: The indicator's registry entry, or None if not found.
    """
    return REGISTRY.get(name.lower())

def list_indicators() -> List[str]:
    """
    Lists all registered indicator names.

    Returns:
        List[str]: A list of registered indicator names.
    """
    return list(REGISTRY.keys())
import inspect
from Data import talib_adapters
from Data import ta_fallback_adapters

def _register_adapters(adapter_module, source_hint: str):
    for name, func in inspect.getmembers(adapter_module, inspect.isfunction):
        if name.isupper() and not name.startswith("_"): # Assuming indicator functions are uppercase
            inputs = ["close"]
            outputs = [name] # Default output name
            defaults = {}

            if name == "MACD":
                inputs = ["close"]
                outputs = ["MACD", "MACD_SIGNAL", "MACD_HIST"]
                defaults = {"fastperiod": 12, "slowperiod": 26, "signalperiod": 9}
            elif name == "BOLLINGER":
                inputs = ["close"]
                outputs = [f"BB_UPPER_{defaults.get('timeperiod', 5)}", f"BB_MIDDLE_{defaults.get('timeperiod', 5)}", f"BB_LOWER_{defaults.get('timeperiod', 5)}"]
                defaults = {"timeperiod": 5, "nbdevup": 2, "nbdevdn": 2, "matype": 0}
            elif name == "STOCH":
                inputs = ["high", "low", "close"]
                outputs = ["STOCH_SLOWK", "STOCH_SLOWD"]
                defaults = {"fastk_period": 5, "slowk_period": 3, "slowk_matype": 0, "slowd_period": 3, "slowd_matype": 0}
            elif name == "ADX" or name == "ATR" or name == "CCI":
                inputs = ["high", "low", "close"]
                outputs = [f"{name}_{defaults.get('timeperiod', 14)}"]
                defaults = {"timeperiod": 14}
            elif name == "OBV":
                inputs = ["close", "volume"]
                outputs = ["OBV"]
            elif name == "SAR":
                inputs = ["high", "low"]
                outputs = ["SAR"]
                defaults = {"acceleration": 0.02, "maximum": 0.2}
            elif name == "VWAP":
                inputs = ["close", "volume"]
                outputs = ["VWAP"]
            else: # SMA, EMA, RSI
                inputs = ["close"]
                outputs = [f"{name}_{defaults.get('timeperiod', 30)}"]
                defaults = {"timeperiod": 30}

            register(name, func, inputs, outputs, defaults, source_hint)

if talib_adapters.HAS_TALIB:
    _register_adapters(talib_adapters, "talib")
else:
    _register_adapters(ta_fallback_adapters, "ta")

# Register custom VWAP if TA-Lib is not available or if it's the preferred fallback
if not talib_adapters.HAS_TALIB:
    register("VWAP", ta_fallback_adapters.VWAP, ["close", "volume"], ["VWAP"], source_hint="custom")
elif talib_adapters.HAS_TALIB and not hasattr(talib_adapters, "VWAP_TALIB_IMPLEMENTED"): # Check if TA-Lib has a real VWAP
    # If TA-Lib is present but doesn't have a direct VWAP, use the custom fallback
    register("VWAP", ta_fallback_adapters.VWAP, ["close", "volume"], ["VWAP"], source_hint="custom")