from typing import Callable, Dict, List, Any

REGISTRY: Dict[str, dict] = {}

def register(name: str, callable: Callable, inputs: List[str], outputs: List[str], defaults: Dict[str, Any] = None, source_hint: str = "custom"):
    """
    Registers an indicator with the global registry.

    Args:
        name (str): The name of the indicator (case-insensitive).
        callable (Callable): The function that computes the indicator.
        inputs (List[str]): A list of required input column names (e.g., ['close']).
        outputs (List[str]): A list of output column names generated by the indicator.
        defaults (Dict[str, Any], optional): Default parameters for the indicator. Defaults to None.
        source_hint (str, optional): A hint about the source of the implementation (e.g., "talib", "ta", "custom"). Defaults to "custom".
    """
    REGISTRY[name.lower()] = {
        "callable": callable,
        "inputs": inputs,
        "outputs": outputs,
        "defaults": defaults or {},
        "source_hint": source_hint,
    }

def get_entry(name: str) -> Dict[str, Any]:
    """
    Retrieves an indicator entry from the registry.

    Args:
        name (str): The name of the indicator (case-insensitive).

    Returns:
        Dict[str, Any]: The indicator's registry entry, or None if not found.
    """
    return REGISTRY.get(name.lower())

def list_indicators() -> List[str]:
    """
    Lists all registered indicator names.

    Returns:
        List[str]: A list of registered indicator names.
    """
    return list(REGISTRY.keys())

import inspect
import talib_adapters
import ta_fallback_adapters

def _parse_docstring(doc: str) -> dict:
    """Parses a structured docstring to extract metadata."""
    metadata = {"inputs": [], "outputs": [], "defaults": {}}
    if not doc:
        return metadata

    lines = [line.strip() for line in doc.strip().split('\n')]
    for line in lines:
        if line.startswith("@inputs:"):
            metadata["inputs"] = [item.strip() for item in line.replace("@inputs:", "").split(',')]
        elif line.startswith("@outputs:"):
            metadata["outputs"] = [item.strip() for item in line.replace("@outputs:", "").split(',')]
        elif line.startswith("@defaults:"):
            defaults_str = line.replace("@defaults:", "").strip()
            if defaults_str:
                # Use ast.literal_eval for safe parsing of dict string
                try:
                    metadata["defaults"] = ast.literal_eval(defaults_str)
                except (ValueError, SyntaxError):
                    print(f"Warning: Could not parse defaults from docstring: {defaults_str}")
    return metadata

def _register_adapters(adapter_module, source_hint: str):
    for name, func in inspect.getmembers(adapter_module, inspect.isfunction):
        if name.isupper() and not name.startswith("_"): # Assuming indicator functions are uppercase
            metadata = _parse_docstring(func.__doc__)
            inputs = metadata.get("inputs")
            outputs = metadata.get("outputs")
            defaults = metadata.get("defaults")
            
            # If docstring is missing, skip registration for this function
            if not all([inputs, outputs]):
                print(f"Skipping registration for '{name}': missing @inputs or @outputs in docstring.")
                continue
                
            register(name, func, inputs, outputs, defaults, source_hint)

if talib_adapters.HAS_TALIB:
    _register_adapters(talib_adapters, "talib")
else:
    _register_adapters(ta_fallback_adapters, "ta")
    # The custom VWAP in ta_fallback_adapters will be registered automatically
    # if it has the correct docstring. This makes the logic cleaner.