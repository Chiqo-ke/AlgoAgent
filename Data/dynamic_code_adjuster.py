# AlgoAgent/Data/dynamic_code_adjuster.py

import ast
import inspect
from typing import List, Dict

class DynamicCodeAdjuster:
    def __init__(self):
        pass

    def _parse_function_body(self, func_code: str) -> ast.FunctionDef:
        """Parses the code of a function and returns its AST."""
        tree = ast.parse(func_code)
        for node in ast.walk(tree):
            if isinstance(node, ast.FunctionDef):
                return node
        raise ValueError("No function definition found in the provided code.")

    def _unparse_ast(self, node: ast.AST) -> str:
        """Unparses an AST node back into code."""
        return ast.unparse(node)

    def update_indicator_calculation_logic(self, current_indicator_calculator_code: str, new_indicator_snippet: str) -> str:
        """
        Updates the `calculate_indicators` method in `indicator_calculator.py`
        with a new or updated indicator calculation snippet.

        This method attempts to find the `calculate_indicators` function and
        insert/replace the new snippet within its conditional logic (if/elif blocks).

        Args:
            current_indicator_calculator_code (str): The full content of the
                                                     indicator_calculator.py file.
            new_indicator_snippet (str): The code snippet for the new/updated indicator,
                                         typically generated by Gemini.

        Returns:
            str: The updated content of the indicator_calculator.py file.
        """
        tree = ast.parse(current_indicator_calculator_code)
        updated_lines = current_indicator_calculator_code.splitlines()
        
        # Find the calculate_indicators method
        for node in ast.walk(tree):
            if isinstance(node, ast.FunctionDef) and node.name == 'calculate_indicators':
                calculate_indicators_node = node
                break
        else:
            raise ValueError("`calculate_indicators` function not found in the provided code.")

        # Find the insertion point within the if/elif chain
        # We'll look for the 'else' block or the last 'elif' block to insert before it
        # or append if no 'else' exists.
        insert_line = -1
        indentation = ""
        
        # Iterate through the body of the calculate_indicators function
        for i, statement in enumerate(calculate_indicators_node.body):
            if isinstance(statement, (ast.If, ast.For, ast.While)): # Look for control flow statements
                # Get the line number of the last line of the statement
                last_line_of_statement = statement.end_lineno
                
                # Get the indentation of the statement
                first_line_of_statement = statement.lineno - 1
                indentation = updated_lines[first_line_of_statement][:statement.col_offset]
                
                # Check if there's an 'else' block or if it's the last statement in the loop
                if isinstance(statement, ast.If) and statement.orelse:
                    # If there's an else block, we want to insert before it
                    insert_line = statement.orelse[0].lineno - 1
                    break
                elif i == len(calculate_indicators_node.body) - 1:
                    # If it's the last statement and no else, append after it
                    insert_line = last_line_of_statement
                    break
            elif i == len(calculate_indicators_node.body) - 1:
                # If no control flow statements, and it's the last statement, append after it
                insert_line = statement.end_lineno
                indentation = updated_lines[statement.lineno - 1][:statement.col_offset]
                break

        if insert_line == -1:
            # Fallback: if no suitable insertion point found, try to insert at the end of the function body
            # This might not be ideal for conditional logic, but ensures insertion.
            insert_line = calculate_indicators_node.end_lineno - 1 # Before the final 'return df'
            # Determine indentation from the last statement in the body
            if calculate_indicators_node.body:
                last_stmt = calculate_indicators_node.body[-1]
                indentation = updated_lines[last_stmt.lineno - 1][:last_stmt.col_offset]
            else:
                # If function body is empty, use the function's own indentation + 4 spaces
                func_indent = updated_lines[calculate_indicators_node.lineno - 1][:calculate_indicators_node.col_offset]
                indentation = func_indent + "    "


        # Prepend indentation to each line of the snippet
        indented_snippet_lines = [indentation + line for line in new_indicator_snippet.splitlines()]
        
        # Insert the new snippet
        updated_lines[insert_line:insert_line] = indented_snippet_lines

        return "\n".join(updated_lines)

if __name__ == "__main__":
    adjuster = DynamicCodeAdjuster()

    # Dummy current code for indicator_calculator.py
    current_code_example = """
import talib
import pandas as pd
import numpy as np

class IndicatorCalculator:
    def __init__(self):
        pass

    def calculate_indicators(self, data: pd.DataFrame, indicators: list) -> pd.DataFrame:
        if data.empty:
            return data

        df = data.copy()

        for indicator_spec in indicators:
            indicator_name = indicator_spec['name'].upper()
            params = {k: v for k, v in indicator_spec.items() if k != 'name'}

            try:
                if indicator_name == 'SMA':
                    df[f'SMA_{params["timeperiod"]}'] = talib.SMA(df['Close'].values, **params)
                elif indicator_name == 'RSI':
                    df[f'RSI_{params["timeperiod"]}'] = talib.RSI(df['Close'].values, **params)
                else:
                    print(f"Warning: Indicator {indicator_name} not implemented or recognized.")

            except Exception as e:
                print(f"Error calculating {indicator_name}: {e}")
        return df
"""

    # Dummy new indicator snippet (as if generated by Gemini)
    new_adx_snippet = """
                elif indicator_name == 'ADX':
                    df[f'ADX_{params["timeperiod"]}'] = talib.ADX(df['High'].values, df['Low'].values, df['Close'].values, **params)"""

    updated_code = adjuster.update_indicator_calculation_logic(current_code_example, new_adx_snippet)
    print("--- Updated indicator_calculator.py code ---")
    print(updated_code)

    # Example with an existing indicator update (e.g., changing SMA logic)
    updated_sma_snippet = """
                if indicator_name == 'SMA':
                    # Updated SMA logic
                    df[f'SMA_UPDATED_{params["timeperiod"]}'] = talib.SMA(df['Close'].values, **params)"""

    # This example is more complex as it requires replacing an existing block.
    # The current implementation primarily focuses on insertion.
    # For replacement, a more sophisticated AST manipulation or string replacement
    # based on identifying the exact block would be needed.
    # For now, we'll demonstrate insertion.
    print("\n--- Attempting to insert another snippet (will append) ---")
    new_macd_snippet = """
                elif indicator_name == 'MACD':
                    macd, macdsignal, macdhist = talib.MACD(df['Close'].values,
                                                            fastperiod=params.get('fastperiod', 12),
                                                            slowperiod=params.get('slowperiod', 26),
                                                            signalperiod=params.get('signalperiod', 9))
                    df['MACD'] = macd
                    df['MACD_Signal'] = macdsignal
                    df['MACD_Hist'] = macdhist"""
    updated_code_with_macd = adjuster.update_indicator_calculation_logic(updated_code, new_macd_snippet)
    print(updated_code_with_macd)