//+------------------------------------------------------------------+
//|                                           PythonSignalExecutor.mq5 |
//|                                  AlgoAgent MT5 Integration        |
//|                                                                    |
//| Expert Advisor to execute signals generated by Python backtester  |
//| References:                                                        |
//| - File Operations: https://www.mql5.com/en/docs/files            |
//| - Trading Operations: https://www.mql5.com/en/docs/trading       |
//+------------------------------------------------------------------+
#property copyright "AlgoAgent"
#property link      "https://github.com/Chiqo-ke/AlgoAgent"
#property version   "1.00"
#property strict

//--- Input parameters
input string   SignalFile = "BT_20241018_120000_XAUUSD_H1_signals.csv"; // Signal file name (in MQL5/Files/)
input double   RiskPercent = 1.0;        // Risk percent per trade (0 = use signal lot size)
input int      Slippage = 10;            // Max slippage in points
input bool     LogVerbose = true;        // Verbose logging
input int      MagicNumber = 20241018;   // Magic number for this EA

//--- Global variables
struct SignalData
{
   datetime timestamp;
   string   symbol;
   string   signal;
   double   lot_size;
   double   stop_loss;
   double   take_profit;
   string   signal_id;
};

SignalData signals[];
int signalCount = 0;
int currentSignalIndex = 0;
bool fileLoaded = false;
datetime lastBarTime = 0;

//+------------------------------------------------------------------+
//| Expert initialization function                                     |
//+------------------------------------------------------------------+
int OnInit()
{
   Print("=== PythonSignalExecutor EA Starting ===");
   Print("Signal File: ", SignalFile);
   Print("Symbol: ", _Symbol);
   Print("Timeframe: ", EnumToString((ENUM_TIMEFRAMES)_Period));
   
   // Load signal file
   if(!LoadSignalFile(SignalFile))
   {
      Print("ERROR: Failed to load signal file: ", SignalFile);
      return(INIT_FAILED);
   }
   
   Print("Successfully loaded ", signalCount, " signals");
   Print("Date range: ", TimeToString(signals[0].timestamp), 
         " to ", TimeToString(signals[signalCount-1].timestamp));
   
   fileLoaded = true;
   return(INIT_SUCCEEDED);
}

//+------------------------------------------------------------------+
//| Expert deinitialization function                                  |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
{
   Print("=== PythonSignalExecutor EA Stopped ===");
   Print("Reason: ", reason);
   Print("Signals processed: ", currentSignalIndex, " / ", signalCount);
}

//+------------------------------------------------------------------+
//| Expert tick function                                               |
//+------------------------------------------------------------------+
void OnTick()
{
   if(!fileLoaded || signalCount == 0)
      return;
   
   // Check if new bar opened
   datetime currentBarTime = iTime(_Symbol, _Period, 0);
   if(currentBarTime == lastBarTime)
      return;  // Not a new bar
   
   lastBarTime = currentBarTime;
   
   // Process signal for current bar
   ProcessSignalForBar(currentBarTime);
}

//+------------------------------------------------------------------+
//| Load signals from CSV file                                         |
//+------------------------------------------------------------------+
bool LoadSignalFile(string filename)
{
   // Open file in MQL5/Files/ directory
   int fileHandle = FileOpen(filename, FILE_READ|FILE_CSV|FILE_ANSI, ',');
   
   if(fileHandle == INVALID_HANDLE)
   {
      Print("ERROR: Cannot open file: ", filename);
      Print("Error code: ", GetLastError());
      Print("Make sure file is in: ", TerminalInfoString(TERMINAL_DATA_PATH), "\\MQL5\\Files\\");
      return false;
   }
   
   // Read header line
   string header = FileReadString(fileHandle);
   if(LogVerbose)
      Print("CSV Header: ", header);
   
   // Read all signals
   int capacity = 10000;  // Initial capacity
   ArrayResize(signals, capacity);
   signalCount = 0;
   
   while(!FileIsEnding(fileHandle))
   {
      // Resize array if needed
      if(signalCount >= capacity)
      {
         capacity *= 2;
         ArrayResize(signals, capacity);
      }
      
      // Read CSV line: Timestamp,Symbol,Signal,LotSize,StopLoss,TakeProfit,SignalID,Metadata
      string timestampStr = FileReadString(fileHandle);
      if(timestampStr == "") break;  // End of file
      
      signals[signalCount].timestamp = StringToTime(timestampStr);
      signals[signalCount].symbol = FileReadString(fileHandle);
      signals[signalCount].signal = FileReadString(fileHandle);
      signals[signalCount].lot_size = StringToDouble(FileReadString(fileHandle));
      signals[signalCount].stop_loss = StringToDouble(FileReadString(fileHandle));
      signals[signalCount].take_profit = StringToDouble(FileReadString(fileHandle));
      signals[signalCount].signal_id = FileReadString(fileHandle);
      
      // Skip metadata field (last column)
      FileReadString(fileHandle);
      
      signalCount++;
   }
   
   FileClose(fileHandle);
   
   // Trim array to actual size
   ArrayResize(signals, signalCount);
   
   return signalCount > 0;
}

//+------------------------------------------------------------------+
//| Process signal for current bar                                     |
//+------------------------------------------------------------------+
void ProcessSignalForBar(datetime barTime)
{
   // Find signal matching current bar time
   SignalData signal;
   bool signalFound = false;
   
   for(int i = currentSignalIndex; i < signalCount; i++)
   {
      // Check if signal timestamp matches current bar
      if(signals[i].timestamp == barTime)
      {
         signal = signals[i];
         currentSignalIndex = i + 1;
         signalFound = true;
         break;
      }
      
      // If signal is in future, stop searching
      if(signals[i].timestamp > barTime)
         break;
      
      // Signal is in past - might be a gap in data
      if(LogVerbose)
         Print("WARNING: Skipped signal at ", TimeToString(signals[i].timestamp));
      currentSignalIndex = i + 1;
   }
   
   if(!signalFound)
   {
      if(LogVerbose)
         Print("No signal for bar: ", TimeToString(barTime));
      return;
   }
   
   // Log signal
   if(LogVerbose)
   {
      Print("=== Signal Found ===");
      Print("Time: ", TimeToString(signal.timestamp));
      Print("Signal: ", signal.signal);
      Print("Lot Size: ", signal.lot_size);
      Print("SL: ", signal.stop_loss, " TP: ", signal.take_profit);
      Print("ID: ", signal.signal_id);
   }
   
   // Execute signal
   ExecuteSignal(signal);
}

//+------------------------------------------------------------------+
//| Execute trading signal                                             |
//+------------------------------------------------------------------+
void ExecuteSignal(SignalData &signal)
{
   // Check if symbol matches
   if(signal.symbol != _Symbol)
   {
      if(LogVerbose)
         Print("WARNING: Signal symbol (", signal.symbol, ") does not match EA symbol (", _Symbol, ")");
      return;
   }
   
   // Get current position
   bool hasPosition = PositionSelect(_Symbol);
   
   // Handle different signal types
   if(signal.signal == "BUY")
   {
      // Close short position if any
      if(hasPosition && PositionGetInteger(POSITION_TYPE) == POSITION_TYPE_SELL)
         ClosePosition();
      
      // Open long position
      if(!hasPosition)
         OpenPosition(ORDER_TYPE_BUY, signal);
   }
   else if(signal.signal == "SELL")
   {
      // Close long position if any
      if(hasPosition && PositionGetInteger(POSITION_TYPE) == POSITION_TYPE_BUY)
         ClosePosition();
      
      // Open short position
      if(!hasPosition)
         OpenPosition(ORDER_TYPE_SELL, signal);
   }
   else if(signal.signal == "EXIT")
   {
      // Close any position
      if(hasPosition)
         ClosePosition();
   }
   else if(signal.signal == "HOLD")
   {
      // Do nothing
      if(LogVerbose)
         Print("HOLD signal - no action");
   }
   else
   {
      Print("WARNING: Unknown signal type: ", signal.signal);
   }
}

//+------------------------------------------------------------------+
//| Open a position                                                    |
//+------------------------------------------------------------------+
void OpenPosition(ENUM_ORDER_TYPE orderType, SignalData &signal)
{
   MqlTradeRequest request = {};
   MqlTradeResult result = {};
   
   // Prepare request
   request.action = TRADE_ACTION_DEAL;
   request.symbol = _Symbol;
   request.volume = signal.lot_size;
   request.type = orderType;
   request.deviation = Slippage;
   request.magic = MagicNumber;
   request.comment = signal.signal_id;
   
   // Set price
   if(orderType == ORDER_TYPE_BUY)
      request.price = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
   else
      request.price = SymbolInfoDouble(_Symbol, SYMBOL_BID);
   
   // Set SL/TP if specified
   if(signal.stop_loss > 0)
      request.sl = signal.stop_loss;
   if(signal.take_profit > 0)
      request.tp = signal.take_profit;
   
   // Send order
   if(!OrderSend(request, result))
   {
      Print("ERROR: OrderSend failed. Error: ", GetLastError());
      Print("Request: Type=", orderType, " Volume=", request.volume, " Price=", request.price);
   }
   else
   {
      if(result.retcode == TRADE_RETCODE_DONE || result.retcode == TRADE_RETCODE_PLACED)
      {
         Print("SUCCESS: Position opened. Ticket: ", result.order, 
               " Volume: ", result.volume, " Price: ", result.price);
      }
      else
      {
         Print("ERROR: Order failed. RetCode: ", result.retcode, 
               " - ", GetTradeRetcodeDescription(result.retcode));
      }
   }
}

//+------------------------------------------------------------------+
//| Close current position                                             |
//+------------------------------------------------------------------+
void ClosePosition()
{
   if(!PositionSelect(_Symbol))
      return;
   
   MqlTradeRequest request = {};
   MqlTradeResult result = {};
   
   // Prepare close request
   request.action = TRADE_ACTION_DEAL;
   request.symbol = _Symbol;
   request.volume = PositionGetDouble(POSITION_VOLUME);
   request.deviation = Slippage;
   request.magic = MagicNumber;
   request.position = PositionGetInteger(POSITION_TICKET);
   
   // Reverse position type for closing
   if(PositionGetInteger(POSITION_TYPE) == POSITION_TYPE_BUY)
   {
      request.type = ORDER_TYPE_SELL;
      request.price = SymbolInfoDouble(_Symbol, SYMBOL_BID);
   }
   else
   {
      request.type = ORDER_TYPE_BUY;
      request.price = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
   }
   
   // Send order
   if(!OrderSend(request, result))
   {
      Print("ERROR: Close position failed. Error: ", GetLastError());
   }
   else
   {
      if(result.retcode == TRADE_RETCODE_DONE)
      {
         Print("SUCCESS: Position closed. Ticket: ", result.order, " Price: ", result.price);
      }
      else
      {
         Print("ERROR: Close failed. RetCode: ", result.retcode);
      }
   }
}

//+------------------------------------------------------------------+
//| Get trade return code description                                  |
//+------------------------------------------------------------------+
string GetTradeRetcodeDescription(uint retcode)
{
   switch(retcode)
   {
      case TRADE_RETCODE_DONE: return "Request completed";
      case TRADE_RETCODE_PLACED: return "Order placed";
      case TRADE_RETCODE_REJECT: return "Request rejected";
      case TRADE_RETCODE_CANCEL: return "Request canceled";
      case TRADE_RETCODE_ERROR: return "Request processing error";
      case TRADE_RETCODE_TIMEOUT: return "Request timeout";
      case TRADE_RETCODE_INVALID: return "Invalid request";
      case TRADE_RETCODE_INVALID_VOLUME: return "Invalid volume";
      case TRADE_RETCODE_INVALID_PRICE: return "Invalid price";
      case TRADE_RETCODE_INVALID_STOPS: return "Invalid stops";
      case TRADE_RETCODE_TRADE_DISABLED: return "Trade disabled";
      case TRADE_RETCODE_MARKET_CLOSED: return "Market closed";
      case TRADE_RETCODE_NO_MONEY: return "Not enough money";
      case TRADE_RETCODE_PRICE_CHANGED: return "Price changed";
      case TRADE_RETCODE_PRICE_OFF: return "No prices";
      case TRADE_RETCODE_INVALID_EXPIRATION: return "Invalid expiration";
      case TRADE_RETCODE_ORDER_CHANGED: return "Order changed";
      case TRADE_RETCODE_TOO_MANY_REQUESTS: return "Too many requests";
      default: return "Unknown error";
   }
}
//+------------------------------------------------------------------+
