# Pattern and Signal Logging System

## Overview

The enhanced backtesting system now includes comprehensive logging for:
1. **Pattern Detection** - Every row of data is analyzed and logged with True/False results
2. **Signal Generation** - All trading signals are logged with full context for later simulation

## New Features

### 1. Pattern Logger (`pattern_logger.py`)

Logs **every row** of market data with pattern detection results:

- **What it logs:**
  - Timestamp and symbol
  - Step ID and description
  - Pattern condition being checked
  - **True/False** whether pattern was found
  - OHLCV market data
  - Indicator values at that moment
  - Additional notes

- **Output:**
  - CSV file: `signals/{strategy_id}_patterns_{timestamp}.csv`
  - Easy to analyze in Excel or Python
  - Shows exactly when and where patterns were detected

### 2. Signal Logger (`signal_logger.py`)

Logs **all trading signals** generated by the strategy:

- **What it logs:**
  - Signal details (BUY/SELL, ENTRY/EXIT, size, price)
  - Reason for signal generation
  - Market data at signal time
  - Indicator values at signal time
  - Strategy internal state
  - Order ID from broker

- **Output:**
  - CSV file: `signals/{strategy_id}_signals_{timestamp}.csv`
  - JSON file: `signals/{strategy_id}_signals_{timestamp}.json`
  - Can be used for trade simulation replay

## How to Use

### In Your Strategy

```python
from Backtest.pattern_logger import PatternLogger
from Backtest.signal_logger import SignalLogger

class YourStrategy:
    def __init__(self, broker, symbol="AAPL", strategy_id="your_strategy"):
        self.broker = broker
        self.symbol = symbol
        
        # Initialize loggers
        self.pattern_logger = PatternLogger(strategy_id)
        self.signal_logger = SignalLogger(strategy_id)
        
        self.in_position = False
    
    def on_bar(self, timestamp, data):
        """Process each bar - EVERY row is logged"""
        symbol_data = data.get(self.symbol)
        
        # Extract market data and indicators
        market_data = {
            'open': symbol_data['open'],
            'high': symbol_data['high'],
            'low': symbol_data['low'],
            'close': symbol_data['close'],
            'volume': symbol_data['volume']
        }
        
        indicators = {
            'EMA_30': symbol_data.get('EMA_30'),
            'EMA_50': symbol_data.get('EMA_50')
        }
        
        # Check entry pattern (LOGGED FOR EVERY ROW)
        pattern_condition = "EMA_30 > EMA_50"
        pattern_found = indicators['EMA_30'] > indicators['EMA_50']
        
        self.pattern_logger.log_pattern(
            timestamp=timestamp,
            symbol=self.symbol,
            step_id="entry_check",
            step_title="Entry Pattern: EMA Crossover",
            pattern_condition=pattern_condition,
            pattern_found=pattern_found,
            market_data=market_data,
            indicator_values=indicators,
            notes="Checking for bullish crossover"
        )
        
        # If pattern found and not in position, generate signal
        if pattern_found and not self.in_position:
            # Log the signal
            self.signal_logger.log_signal(
                timestamp=timestamp,
                symbol=self.symbol,
                side="BUY",
                action="ENTRY",
                order_type="MARKET",
                size=100,
                price=market_data['close'],
                reason="EMA_30 crossed above EMA_50",
                market_data=market_data,
                indicator_values=indicators,
                strategy_state={'in_position': False}
            )
            
            # Submit to broker
            signal = create_signal(...)
            self.broker.submit_signal(signal.to_dict())
            
            self.in_position = True
    
    def finalize(self):
        """Close loggers and export summaries"""
        self.pattern_logger.close()
        self.signal_logger.close()
```

### Sequential Data Processing

The new flow ensures **every row** is processed sequentially:

```python
# Load data with indicators
df = load_market_data(
    ticker="AAPL",
    period="6mo",
    interval="1d",
    indicators=[
        {"name": "EMA", "params": {"period": 30}},
        {"name": "EMA", "params": {"period": 50}}
    ]
)

# Process row by row
for idx, row in df.iterrows():
    timestamp = idx
    
    market_data = {
        "AAPL": {
            'open': row['open'],
            'close': row['close'],
            # ... other data
            'EMA_30': row['EMA_30'],
            'EMA_50': row['EMA_50']
        }
    }
    
    # Strategy logs pattern for THIS row
    strategy.on_bar(timestamp, market_data)
    
    # Broker executes any signals
    broker.step_to(timestamp, market_data)

# Close loggers
strategy.finalize()
```

## Output Files

### Pattern Log (CSV)
Located in: `Backtest/signals/{strategy_id}_patterns_{timestamp}.csv`

| timestamp | symbol | step_id | pattern_condition | pattern_found | close | EMA_30 | EMA_50 |
|-----------|--------|---------|-------------------|---------------|-------|--------|--------|
| 2025-01-01 10:00 | AAPL | entry_check | EMA_30 > EMA_50 | False | 150.00 | 149.5 | 150.2 |
| 2025-01-01 10:01 | AAPL | entry_check | EMA_30 > EMA_50 | False | 150.50 | 149.7 | 150.1 |
| 2025-01-01 10:02 | AAPL | entry_check | EMA_30 > EMA_50 | **True** | 151.00 | 150.3 | 150.0 |

### Signal Log (CSV)
Located in: `Backtest/signals/{strategy_id}_signals_{timestamp}.csv`

| signal_id | timestamp | symbol | side | action | size | price | reason | order_id |
|-----------|-----------|--------|------|--------|------|-------|--------|----------|
| SIG_001 | 2025-01-01 10:02 | AAPL | BUY | ENTRY | 100 | 151.00 | EMA crossover | ORD_123 |
| SIG_002 | 2025-01-01 14:30 | AAPL | SELL | EXIT | 100 | 152.50 | Stop loss hit | ORD_124 |

### Signal Log (JSON)
Located in: `Backtest/signals/{strategy_id}_signals_{timestamp}.json`

Contains full signal details with nested objects for indicators, market data, and strategy state.

## Benefits

### 1. Debugging Made Easy
- See exactly which rows triggered patterns
- Identify False positives/negatives
- Verify indicator calculations
- Track strategy decision-making process

### 2. Signal Verification
- All signals logged with full context
- Can replay signals for analysis
- Verify signal generation logic
- Compare signals vs actual trades

### 3. Trade Simulation
- Use signal logs to simulate trades later
- Test different execution strategies
- Analyze signal quality
- Build signal performance dashboard

### 4. Pattern Analysis
- Calculate pattern detection rates
- Find optimal entry/exit patterns
- Compare pattern performance
- Optimize strategy parameters

## Example: Running a Test

```bash
# Run the test script
python Backtest/test_logging_system.py
```

This will:
1. Load AAPL data with EMA indicators
2. Process every row sequentially
3. Log all pattern checks (True/False)
4. Log all trading signals
5. Generate summary reports
6. Save logs to `signals/` folder

## Template Strategy

See `strategy_template_enhanced.py` for a complete example of:
- Pattern logging for entry/exit
- Signal logging with full context
- Sequential data processing
- Logger finalization and summaries

## Integration with Strategy Manager

The Strategy Manager (`strategy_manager.py`) will automatically generate strategies using the new template with logging enabled by default.

## Files Created

1. `pattern_logger.py` - Pattern detection logging
2. `signal_logger.py` - Trading signal logging
3. `strategy_template_enhanced.py` - Enhanced template with logging
4. `test_logging_system.py` - Test script demonstrating features
5. `LOGGING_SYSTEM.md` - This documentation

## Updated Files

1. `SYSTEM_PROMPT.md` - Updated to include logging in generated strategies
2. Strategy generation now includes pattern and signal logging by default

## Next Steps

1. **Run the test**: `python Backtest/test_logging_system.py`
2. **Check the logs**: Look in `Backtest/signals/` folder
3. **Update existing strategies**: Add pattern and signal logging
4. **Generate new strategies**: They'll include logging automatically
